{"ast":null,"code":"/*!\r\n * Ladda\r\n * http://lab.hakim.se/ladda\r\n * MIT licensed\r\n *\r\n * Copyright (C) 2018 Hakim El Hattab, http://hakim.se\r\n */\nimport { Spinner } from 'spin.js'; // All currently instantiated instances of Ladda\n\nvar ALL_INSTANCES = [];\n/**\r\n * Creates a new instance of Ladda which wraps the\r\n * target button element.\r\n *\r\n * @return An API object that can be used to control\r\n * the loading animation state.\r\n */\n\nexport function create(button) {\n  if (typeof button === 'undefined') {\n    console.warn(\"Ladda button target must be defined.\");\n    return;\n  } // The button must have the class \"ladda-button\"\n\n\n  if (!button.classList.contains('ladda-button')) {\n    button.classList.add('ladda-button');\n  } // Style is required, default to \"expand-right\"\n\n\n  if (!button.hasAttribute('data-style')) {\n    button.setAttribute('data-style', 'expand-right');\n  } // The text contents must be wrapped in a ladda-label\n  // element, create one if it doesn't already exist\n\n\n  if (!button.querySelector('.ladda-label')) {\n    var laddaLabel = document.createElement('span');\n    laddaLabel.className = 'ladda-label';\n    wrapContent(button, laddaLabel);\n  } // The spinner component\n\n\n  var spinnerWrapper = button.querySelector('.ladda-spinner'); // Wrapper element for the spinner\n\n  if (!spinnerWrapper) {\n    spinnerWrapper = document.createElement('span');\n    spinnerWrapper.className = 'ladda-spinner';\n  }\n\n  button.appendChild(spinnerWrapper); // Timer used to delay starting/stopping\n\n  var timer;\n  var spinner;\n  var instance = {\n    /**\r\n     * Enter the loading state.\r\n     */\n    start: function () {\n      // Create the spinner if it doesn't already exist\n      if (!spinner) {\n        spinner = createSpinner(button);\n      }\n\n      button.disabled = true;\n      button.setAttribute('data-loading', '');\n      clearTimeout(timer);\n      spinner.spin(spinnerWrapper);\n      this.setProgress(0);\n      return this; // chain\n    },\n\n    /**\r\n     * Enter the loading state, after a delay.\r\n     */\n    startAfter: function (delay) {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        instance.start();\n      }, delay);\n      return this; // chain\n    },\n\n    /**\r\n     * Exit the loading state.\r\n     */\n    stop: function () {\n      if (instance.isLoading()) {\n        button.disabled = false;\n        button.removeAttribute('data-loading');\n      } // Kill the animation after a delay to make sure it\n      // runs for the duration of the button transition\n\n\n      clearTimeout(timer);\n\n      if (spinner) {\n        timer = setTimeout(function () {\n          spinner.stop();\n        }, 1000);\n      }\n\n      return this; // chain\n    },\n\n    /**\r\n     * Toggle the loading state on/off.\r\n     */\n    toggle: function () {\n      return this.isLoading() ? this.stop() : this.start();\n    },\n\n    /**\r\n     * Sets the width of the visual progress bar inside of\r\n     * this Ladda button\r\n     *\r\n     * @param {number} progress in the range of 0-1\r\n     */\n    setProgress: function (progress) {\n      // Cap it\n      progress = Math.max(Math.min(progress, 1), 0);\n      var progressElement = button.querySelector('.ladda-progress'); // Remove the progress bar if we're at 0 progress\n\n      if (progress === 0 && progressElement && progressElement.parentNode) {\n        progressElement.parentNode.removeChild(progressElement);\n      } else {\n        if (!progressElement) {\n          progressElement = document.createElement('div');\n          progressElement.className = 'ladda-progress';\n          button.appendChild(progressElement);\n        }\n\n        progressElement.style.width = (progress || 0) * button.offsetWidth + 'px';\n      }\n    },\n    isLoading: function () {\n      return button.hasAttribute('data-loading');\n    },\n    remove: function () {\n      clearTimeout(timer);\n      button.disabled = false;\n      button.removeAttribute('data-loading');\n\n      if (spinner) {\n        spinner.stop();\n        spinner = null;\n      }\n\n      ALL_INSTANCES.splice(ALL_INSTANCES.indexOf(instance), 1);\n    }\n  };\n  ALL_INSTANCES.push(instance);\n  return instance;\n}\n/**\r\n * Binds the target buttons to automatically enter the\r\n * loading state when clicked.\r\n *\r\n * @param target Either an HTML element or a CSS selector.\r\n * @param options\r\n *          - timeout Number of milliseconds to wait before\r\n *            automatically cancelling the animation.\r\n *          - callback A function to be called with the Ladda\r\n *            instance when a target button is clicked.\r\n */\n\nexport function bind(target, options) {\n  var targets;\n\n  if (typeof target === 'string') {\n    targets = document.querySelectorAll(target);\n  } else if (typeof target === 'object') {\n    targets = [target];\n  } else {\n    throw new Error('target must be string or object');\n  }\n\n  options = options || {};\n\n  for (var i = 0; i < targets.length; i++) {\n    bindElement(targets[i], options);\n  }\n}\n/**\r\n * Stops ALL current loading animations.\r\n */\n\nexport function stopAll() {\n  for (var i = 0, len = ALL_INSTANCES.length; i < len; i++) {\n    ALL_INSTANCES[i].stop();\n  }\n}\n/**\r\n* Get the first ancestor node from an element, having a\r\n* certain type.\r\n*\r\n* @param elem An HTML element\r\n* @param type an HTML tag type (uppercased)\r\n*\r\n* @return An HTML element\r\n*/\n\nfunction getAncestorOfTagType(elem, type) {\n  while (elem.parentNode && elem.tagName !== type) {\n    elem = elem.parentNode;\n  }\n\n  return type === elem.tagName ? elem : undefined;\n}\n\nfunction createSpinner(button) {\n  var height = button.offsetHeight,\n      spinnerColor,\n      spinnerLines;\n\n  if (height === 0) {\n    // We may have an element that is not visible so\n    // we attempt to get the height in a different way\n    height = parseFloat(window.getComputedStyle(button).height);\n  } // If the button is tall we can afford some padding\n\n\n  if (height > 32) {\n    height *= 0.8;\n  } // Prefer an explicit height if one is defined\n\n\n  if (button.hasAttribute('data-spinner-size')) {\n    height = parseInt(button.getAttribute('data-spinner-size'), 10);\n  } // Allow buttons to specify the color of the spinner element\n\n\n  if (button.hasAttribute('data-spinner-color')) {\n    spinnerColor = button.getAttribute('data-spinner-color');\n  } // Allow buttons to specify the number of lines of the spinner\n\n\n  if (button.hasAttribute('data-spinner-lines')) {\n    spinnerLines = parseInt(button.getAttribute('data-spinner-lines'), 10);\n  }\n\n  var radius = height * 0.2,\n      length = radius * 0.6,\n      width = radius < 7 ? 2 : 3;\n  return new Spinner({\n    color: spinnerColor || '#fff',\n    lines: spinnerLines || 12,\n    radius: radius,\n    length: length,\n    width: width,\n    animation: 'ladda-spinner-line-fade',\n    zIndex: 'auto',\n    top: 'auto',\n    left: 'auto',\n    className: ''\n  });\n}\n\nfunction wrapContent(node, wrapper) {\n  var r = document.createRange();\n  r.selectNodeContents(node);\n  r.surroundContents(wrapper);\n  node.appendChild(wrapper);\n}\n\nfunction bindElement(element, options) {\n  if (typeof element.addEventListener !== 'function') {\n    return;\n  }\n\n  var instance = create(element);\n  var timeout = -1;\n  element.addEventListener('click', function () {\n    // If the button belongs to a form, make sure all the\n    // fields in that form are filled out\n    var valid = true;\n    var form = getAncestorOfTagType(element, 'FORM');\n\n    if (typeof form !== 'undefined' && !form.hasAttribute('novalidate')) {\n      // Modern form validation\n      if (typeof form.checkValidity === 'function') {\n        valid = form.checkValidity();\n      }\n    }\n\n    if (valid) {\n      // This is asynchronous to avoid an issue where disabling\n      // the button prevents forms from submitting\n      instance.startAfter(1); // Set a loading timeout if one is specified\n\n      if (typeof options.timeout === 'number') {\n        clearTimeout(timeout);\n        timeout = setTimeout(instance.stop, options.timeout);\n      } // Invoke callbacks\n\n\n      if (typeof options.callback === 'function') {\n        options.callback.apply(null, [instance]);\n      }\n    }\n  }, false);\n}","map":null,"metadata":{},"sourceType":"module"}